- zookeeper
    - 解决什么问题 设计目的和动机
        - 协同工作 任务协调器
            - 串行 任务的先后顺序  原先采用分布式锁
            - 并行 任务的分配 原先采用分布式数据库
                - 主节点崩溃
        - 保存元数据
        - 奔溃检测
            - 从节点崩溃
            - 通信故障
        - 不适合做的事情
            - 大数据量的存储
                - 从应用数据和协同数据角度出发
                - 一致性和持久性的不同需求
    - 用了什么技术背后原理是什么
        - 简单的并发处理机制
            - Znode 乐观锁 版本号实现
        - 奇数选举原则
            - 更好的错误容忍性
    - 现在应用在哪些场景
        - 持久节点
        - 临时节点
        - 有序节点
        - 独立模式
        - 仲裁模式（集群模式）
- 新名词
    - Fast paxos 算法
    - 应用数据
    - 协同数据
    - 同步原语
    - 有序存储组件
    - 网络分区
    - 脑裂
    - 仅一次  最多一次
    - FLP原理
    - raft算法
    - 虚拟同步技术
    - protocol buffers
    - thfit
    - Avro
    - messafePack
    - 轮询机制
    - 通知机制
    - 仲裁理论
    - 群首选举算法
    - Zab算法（paxos算法改进）
    - curator（zkclient客户端的替代）
    - UGO 用户权限控制模型 user group other
- 一些需要check的点
    - Watch机制是否可以长久 如果一直watch 顺序性如何保证 即A 、B更新后 网络B、A到达
    - 主从机制、数据写入确定 是节点都写入  还是主节点写入就算完成
        - 解决是多数保存 zookeeper 仲裁机制
        - 仲裁完立马读 读取的节点刚好是没有保存的节点 怎么处理 即 非强一致问题如何处理e
        - 客户端服务器端 保持连接版本一致， 即通过排序 ，保证更新操作执行的之后的服务器，只能读到同样更新之后的服务器 zxid
